{
  "name": "Pinecone Upload Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pinecone-upload",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger-001",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "pinecone-upload-webhook"
    },
    {
      "parameters": {
        "functionCode": "const body = $input.item.json.body || $input.item.json;\nconst files = body.files || [];\nconst namespace = body.namespace || 'default';\n\nif (!Array.isArray(files) || files.length === 0) {\n  throw new Error('files array is required. Format: {\"files\": [{\"fileName\": \"test.txt\", \"text\": \"content...\"}], \"namespace\": \"default\"}');\n}\n\nreturn files.map(file => ({\n  json: {\n    fileName: file.fileName || 'unknown.txt',\n    text: file.text || file.content || '',\n    source: (file.fileName || 'unknown').replace('.txt', ''),\n    namespace: namespace\n  }\n}));"
      },
      "id": "parse-input-002",
      "name": "Parse Input",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "functionCode": "const inputItem = $input.item;\nconst inputData = inputItem.json || {};\n\nconst text = inputData.text;\nconst source = inputData.source || inputData.fileName || 'unknown';\nconst namespace = inputData.namespace || 'default';\n\nif (!text || typeof text !== 'string') {\n  throw new Error(`Text field is required. File: ${source}`);\n}\n\nconst chunkSize = 600;\nconst overlap = 100;\nconst chunks = [];\nlet index = 0;\n\nfor (let i = 0; i < text.length; i += chunkSize - overlap) {\n  const chunk = text.slice(i, i + chunkSize);\n  if (chunk.trim().length > 0) {\n    chunks.push({\n      id: `chunk_${source}_${Date.now()}_${index}`,\n      text: chunk,\n      chunk_index: index,\n      source: source\n    });\n    index++;\n  }\n}\n\nreturn [{\n  json: {\n    chunks: chunks,\n    namespace: namespace,\n    source: source\n  }\n}];"
      },
      "id": "chunk-text-003",
      "name": "Chunk Text",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "functionCode": "const chunks = $input.item.json.chunks;\nconst texts = chunks.map(chunk => chunk.text);\n\nreturn [{\n  json: {\n    texts: texts,\n    chunks: chunks\n  }\n}];"
      },
      "id": "prepare-batch-004",
      "name": "Prepare Batch",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/embeddings",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "HTTP-Referer",
              "value": "http://localhost:5678"
            },
            {
              "name": "X-Title",
              "value": "n8n Pinecone Workflow"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": []
        },
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"openai/text-embedding-3-large\",\n  \"input\": $json.texts,\n  \"dimensions\": 3072\n} }}",
        "options": {}
      },
      "id": "get-embeddings-005",
      "name": "Get Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1120, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "openai-credentials",
          "name": "OpenRouter API"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "const embeddingsResponse = $input.item.json;\nconst chunks = $('Prepare Batch').item.json.chunks;\nconst namespace = $('Chunk Text').item.json.namespace;\n\nif (!embeddingsResponse.data || !Array.isArray(embeddingsResponse.data)) {\n  throw new Error('Invalid embeddings response');\n}\n\nconst vectors = embeddingsResponse.data.map((item, index) => ({\n  id: chunks[index].id,\n  values: item.embedding,\n  metadata: {\n    text: chunks[index].text,\n    source: chunks[index].source,\n    chunk_index: chunks[index].chunk_index\n  }\n}));\n\nreturn [{\n  json: {\n    vectors: vectors,\n    namespace: namespace,\n    vectorsCount: vectors.length\n  }\n}];"
      },
      "id": "format-pinecone-006",
      "name": "Format for Pinecone",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.PINECONE_ENDPOINT || 'https://elegant-cedar-7ro4j83.svc.aped-4627-b74a.pinecone.io' }}/vectors/upsert",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": []
        },
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"vectors\": $json.vectors,\n  \"namespace\": $json.namespace\n} }}",
        "options": {}
      },
      "id": "upsert-pinecone-007",
      "name": "Upsert to Pinecone",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1560, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "pinecone-credentials",
          "name": "Pinecone API"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "const allUpsertResponses = $input.all();\nlet totalUpserted = 0;\nconst fileResults = [];\n\nallUpsertResponses.forEach((item, index) => {\n  const response = item.json;\n  const upsertedCount = response.upsertedCount || 0;\n  \n  totalUpserted += upsertedCount;\n  \n  fileResults.push({\n    fileIndex: index + 1,\n    upserted: upsertedCount\n  });\n});\n\nconst filesProcessed = $('Parse Input').all().length;\n\nreturn [{\n  json: {\n    status: 'success',\n    totalFiles: filesProcessed,\n    totalUpserted: totalUpserted,\n    fileResults: fileResults\n  }\n}];"
      },
      "id": "aggregate-results-008",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-webhook-009",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Parse Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input": {
      "main": [
        [
          {
            "node": "Chunk Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chunk Text": {
      "main": [
        [
          {
            "node": "Prepare Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Batch": {
      "main": [
        [
          {
            "node": "Get Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Embeddings": {
      "main": [
        [
          {
            "node": "Format for Pinecone",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Pinecone": {
      "main": [
        [
          {
            "node": "Upsert to Pinecone",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert to Pinecone": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}
